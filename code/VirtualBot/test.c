#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Sensor, S2,     compassSensor,       sensorVirtualCompass)
#pragma config(Sensor, S3,     lightSensor,         sensorLightActive)
#pragma config(Sensor, S4,     sonarSensor,         sensorSONAR)
#pragma config(Motor,  motorA,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorRight,    tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorLeft,     tmotorNormal, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#if 0
/// Copyright (c) Titan Robotics Club. All rights reserved.
///
/// <module name="Auto.c" />
///
/// <summary>
///     This module contains the entry point for autonomous mode.
///     This is template file and should not be modified. The main competition
///     code should live in AutoMain.h.
/// </summary>
///
/// <remarks>
///     Environment: RobotC for Lego Mindstorms NXT.
/// </remarks>
#endif

#include "JoystickDriver.c"

#define DEADBAND_INPUT_THRESHOLD 20
#define MOTOR_MIN_VALUE         -100
#define MOTOR_MAX_VALUE         100

#define BOUND(n,l,h)            (((n) < (l))? (l): ((n) > (h))? (h): (n))
#define NORMALIZE(n,sl,sh,tl,th) (int)(((long)(n) - (sl))*((th) - (tl))/((sh) - (sl)) + (tl))
#define DEADBAND(n,t)           ((abs(n) > (t))? (n): 0)
#define DEADBAND_INPUT(n)       DEADBAND(n, DEADBAND_INPUT_THRESHOLD)
#define NORMALIZE_DRIVE(x,m,n)  NORMALIZE(x, m, n, MOTOR_MIN_VALUE, MOTOR_MAX_VALUE)

/**
 *  This task is the program entry point.
 */
task main()
{
    int drivePower;
    int turnPower;
    int sonarData;

    while (true)
    {
        getJoystickSettings(joystick);
        drivePower = NORMALIZE_DRIVE(DEADBAND_INPUT(joystick.joy1_y1), MOTOR_MIN_VALUE, MOTOR_MAX_VALUE);
        turnPower = NORMALIZE_DRIVE(DEADBAND_INPUT(joystick.joy1_x1), MOTOR_MIN_VALUE, MOTOR_MAX_VALUE);
        nxtDisplayTextLine(2, "D=%4d,T=%4d", drivePower, turnPower);
        if ((drivePower == 0) && (turnPower == 0))
        {
            sonarData = SensorValue(sonarSensor);
            if (sonarData >= 30)
            {
                motor[motorLeft] = 100;
                motor[motorRight] = 100;
            }
            else
            {
                motor[motorLeft] = 100;
                motor[motorRight] = -100;
            }
        }
        else
        {
            int leftPower = BOUND((drivePower + turnPower), MOTOR_MIN_VALUE, MOTOR_MAX_VALUE);
            int rightPower = BOUND((drivePower - turnPower), MOTOR_MIN_VALUE, MOTOR_MAX_VALUE);
            motor[motorLeft] = leftPower;
            motor[motorRight] = rightPower;
            nxtDisplayTextLine(3, "L=%4d,R=%4d", leftPower, rightPower);
        }
        wait1Msec(10);
    }
}   //main
